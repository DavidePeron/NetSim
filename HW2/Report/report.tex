\documentclass[11pt,a4paper]{article}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{lipsum}
\usepackage{eurosym}
\usepackage{rotating}

\usepackage{amsmath, amssymb, amsfonts, amsthm, mathtools}
% mathtools for: Aboxed (put box on last equation in align environment)
\usepackage{microtype} %improves the spacing between words and letters

% Packages for tables
\usepackage{threeparttable}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{booktabs}

\usepackage{lipsum}
\usepackage{threeparttable}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{booktabs}
\newcommand{\tabitem}{~~\llap{\textbullet}~~}
\usepackage{graphicx}
\graphicspath{ {./figures/} {./eps/}}
\usepackage{epsfig}
\usepackage{epstopdf}
\usepackage{verbatim}
\usepackage{textcomp}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\geometry{vmargin={2cm, 2cm}}
% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% COLOR DEFINITIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 % Enabling mixing colors and color's call by 'svgnames'
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\definecolor{MyColor1}{HTML}{CC0000} %mix personal color
\newcommand{\textb}{\color{Black} \usefont{OT1}{lmss}{m}{n}}
\newcommand{\blue}{\color{MyColor1} \usefont{OT1}{lmss}{m}{n}}
\newcommand{\blueb}{\color{MyColor1} \usefont{OT1}{lmss}{b}{n}}
\newcommand{\red}{\color{LightCoral} \usefont{OT1}{lmss}{m}{n}}
\newcommand{\green}{\color{Turquoise} \usefont{OT1}{lmss}{m}{n}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Scala coloring settings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% "define" Scala
\usepackage{listings}
\usepackage{xcolor}
\lstset{escapeinside={<@}{@>}}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
}}

% Python environment
\lstnewenvironment{python}[1][]
{
\pythonstyle
\lstset{#1}
}
{}

% Python for external files
\newcommand\pythonexternal[2][]{{
\pythonstyle
\lstinputlisting[#1]{#2}}}

% Python for inline
\newcommand\pythoninline[1]{{\pythonstyle\lstinline!#1!}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FONTS AND COLORS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		SECTIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{titlesec}
\usepackage{sectsty}
%%%%%%%%%%%%%%%%%%%%%%%%
%set section/subsections HEADINGS font and color
\sectionfont{\color{MyColor1}}  % sets colour of sections
\subsectionfont{\color{MyColor1}}  % sets colour of sections

%set section enumerator to arabic number (see footnotes markings alternatives)
\renewcommand\thesection{Exercise \arabic{section}} %define sections numbering
\renewcommand\thesubsection{\thesection.\arabic{subsection}} %subsec.num.

%define new section style
\newcommand{\mysection}{
\titleformat{\section} [runin] {\usefont{OT1}{lmss}{b}{n}\color{MyColor1}}
{\thesection} {3pt} {} }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		CAPTIONS
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{caption}
\usepackage{subcaption}
%%%%%%%%%%%%%%%%%%%%%%%%
\captionsetup[figure]{labelfont={color=MyColor1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		!!!EQUATION (ARRAY) --> USING ALIGN INSTEAD
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%using amsmath package to redefine eq. numeration (1.1, 1.2, ...)
%%%%%%%%%%%%%%%%%%%%%%%%
\renewcommand{\theequation}{\arabic{equation}}

%set box background to grey in align environment
\usepackage{etoolbox}% http://ctan.org/pkg/etoolbox
\makeatletter
\patchcmd{\@Aboxed}{\boxed{#1#2}}{\colorbox{black!15}{$#1#2$}}{}{}%
\patchcmd{\@boxed}{\boxed{#1#2}}{\colorbox{black!15}{$#1#2$}}{}{}%
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\DP}[1]{\textcolor{blue}{\textbf{(DP says: #1)}}}

\makeatletter
\let\reftagform@=\tagform@
\def\tagform@#1{\maketag@@@{(\ignorespaces\textcolor{red}{#1}\unskip\@@italiccorr)}}
\renewcommand{\eqref}[1]{\textup{\reftagform@{\ref{#1}}}}
\makeatother
\usepackage[hidelinks]{hyperref}

%% LISTS CONFIGURATION %%
\usepackage{enumitem}
\setlist[enumerate,1]{start=0}
\renewcommand{\labelenumii}{\theenumii}
\renewcommand{\theenumii}{\theenumi.\arabic{enumii}.}

\usepackage[acronym]{glossaries}
\newacronym{ci}{CI}{Confidence Interval}
\newacronym{pi}{PI}{Prediction Interval}
\newacronym{lcg}{LCG}{Linear Congruence Generator}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PREPARE TITLE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{\blue Network analysis and simulation\\ Homework 1}
\author{Davide Peron}
\date{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\maketitle
\section{}
In \autoref{fig:6_5a}, \autoref{fig:6_5b}, \autoref{fig:6_5c}, \autoref{fig:6_7a} and \autoref{fig:6_7b}, the behavior of a \gls{lcg} has been studied. In the last two figures, the two \textit{non-standard} distributions have been taken in account. In \autoref{fig:6_10a} the distribution is
$$
f_Y(y) = K\frac{sin^2(y)}{y^2}\mathbf{1}_{\{-a \le y \le a\}}
$$
with $a=10$, while in \autoref{fig:6_10b} there are a set of sample of the random vector $(X_1, X_2)$ with a density proportional to $|X_1 - X_2|$.

In the follow the said figures are reported.

\begin{figure}[ht]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{fig-6_5a}
		\caption{QQPlot of the \gls{lcg} versus a uniform distribution (Figure 6.5a)}
		\label{fig:6_5a}
	\end{minipage}
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{fig-6_5b}
		\caption{Autocorrelation of the \gls{lcg} (Figure 6.5b)}
		\label{fig:6_5b}
	\end{minipage}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.9\textwidth]{fig-6_5c}
  \caption{Lag plots (Figure 6.5c)}
  \label{fig:6_5c}
\end{figure}

\begin{figure}[ht]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{fig-6_7a}
		\caption{Behavior of two parallel stream using seed $s=1$ and $s=2$ (Figure 6.7a) }
		\label{fig:6_7a}
	\end{minipage}
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{fig-6_7b}
		\caption{Behavior of two parallel stream using seed $s=1$ and $s=568$ (Figure 6.7b)}
		\label{fig:6_7b}
	\end{minipage}
\end{figure}

\begin{figure}[ht]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{fig-6_10a}
		\caption{Histograms of a set of sample from the first \textit{weird} distribution (Figure 6.10a)}
		\label{fig:6_10a}
	\end{minipage}
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{fig-6_10b}
		\caption{Set of sample from the second \textit{weird} distribution (Figure 6.10b)}
		\label{fig:6_10b}
	\end{minipage}
\end{figure}

\newpage
\section{}
Trying to generate a Binomial random variables $B(n,p)$ with $n=50$ and $p=0.5$, we can see that the fastest approach is the CDF inversion technique, although extracting $n$ Bernoulli rvs is much faster than the Geometric method.
In the follow, the three different implementations are presented.

The first method inplemented is the one of the CDF inversion.
\begin{python}
  # With CDF inversion

X_CDF = []
F_CDF = []
start = time.time()
c = theta/(1-theta)
for _ in range(0,n_rvs):
    pr = (1-theta)**n
    u = np.random.rand()
    i = 0
    F = pr
    while u >= F:
        pr *= c*(n-i)/(i+1)
        F += pr
        i += 1
    X_CDF.append(i)
    F_CDF.append(F)
    mean_CDF += i
end = time.time()
time_CDF = end - start
\end{python}

A Binomial Random Variable can also be created drawing $n$ Bernoulli rvs and counting the successes.
\begin{python}
  # Drawing n Bernoulli rvs
start = time.time()

for _ in range(0,n_rvs):
    X_bernoulli = 0
    for i in range(0,50):
        u = np.random.rand()
        if u > 0.5: #Success
            X_bernoulli += 1
    mean_bernoulli += X_bernoulli
end = time.time()
time_bernoulli = end - start
\end{python}

A method to avoid to draw $n$ Bernoulli rvs is to count how much geometric fits into $n$ trials, although this approach is the one that requires less operations, is the slower one, probably due to the computational complexity of the $log$ function.

For each approach, $10000$ realization of the rv has been created. The time elapsed by each technique is reported in \autoref{table:simTime}.

\begin{python}
  # Using Geometric Distribution

start = time.time()
for _ in range(0,n_rvs):
    isFinished = False
    X_geometric = 0
    count = 0
    while not isFinished:
        u = np.random.rand()
        X_geometric += np.floor(np.log(u)/np.log(1-theta)) + 1
        if X_geometric >= n :
            isFinished = True
        if X_geometric <= n:
            count += 1
    mean_geometric += count
end = time.time()
time_geometric = end - start
\end{python}

\begin{table}[ht]
\small
	\centering
    \renewcommand{\arraystretch}{1}% Tighter
	\begin{tabular}{@{}lll@{}}
	\toprule
    Type & Time elapsed(s) & Mean of rv\\ \midrule
    CDF Inversion & 0.1165218 & 25.0093\\
    Bernoulli & 0.2815795 & 24.9886\\
    Geometric & 2.1662595 & 24.9641\\
    \bottomrule
    \end{tabular}
	\caption{Time elapsed in the different simulations creating a Binomial random variable.} 
	\label{table:simTime}
\end{table}


\section{}
Trying to generate a Poisson random variables $P(\lambda)$ with $\lambda = 5$, we can see that, also in this case, the fastest method is the CDF inversion technique, immediately followed by the Uniform rvs method and the Exponential one.
In the follow, the three different implementations are presented.
For each approach, $10000$ realization of the rv has been created. The time elapsed by each technique is reported in \autoref{table:simTimePoisson}.

The first method inplemented is the one of the CDF inversion.
\begin{python}
#CDF Inversion
mean_CDF = 0
start = time.time()
for k in range(0,n_vars):
    u = np.random.rand()
    i = 0
    p = math.exp(-lambda_par)
    F = p
    while u >= F:
        p *= lambda_par/(i+1)
        F += p
        i += 1
    mean_CDF += i

mean_CDF /= n_vars
end = time.time()
time_CDF = end - start
\end{python}

A Poisson Random Variable can also be created counting the number of exponential rvs that you can draw until their sum is less than $1$.
\begin{python}
#Sum of exponentials
mean_exp = 0
start = time.time()
for i in range(0,n_vars):
    n_exp = 0
    sum = 0
    while sum <= 1:
        sum += -math.log(np.random.rand())/lambda_par
        n_exp += 1
    mean_exp += n_exp - 1

mean_exp /= n_vars
end = time.time()
time_exp = end - start
\end{python}

The last method is using uniforms as long as their product is greater than $e^{-\lambda}$.
\begin{python}
  #Product of uniforms
mean_unif = 0
start = time.time()
for i in range(0,n_vars):
    rv = 1
    count = 0
    while rv > math.exp(-lambda_par):
        rv *= np.random.rand()
        count += 1
    mean_unif += count - 1

mean_unif /= n_vars
end = time.time()
time_unif = end - start
\end{python}

\begin{table}[ht]
\small
	\centering
    \renewcommand{\arraystretch}{1}% Tighter
	\begin{tabular}{@{}lll@{}}
	\toprule
    Type & Time elapsed(s) & Mean of rv\\ \midrule
    CDF Inversion & 0.02857 & 5.0246\\
    Exponential & 0.05651 & 4.9638\\
    Uniform & 0.05166 & 5.0179\\
    \bottomrule
    \end{tabular}
	\caption{Time elapsed in the different simulations creating a Poisson random variable.}
	\label{table:simTimePoisson}
\end{table}

\section{}
The last two exercise show how random numbers generated with a \gls{lcg} are not \textit{properly} random.
The general formula of a \gls{lcg} is in \autoref{eq:lcg}.
\begin{equation}
  \label{eq:lcg}
  x_n = (a \cdot x_{n-1} + b)mod ~m
\end{equation}
In fourth exercise two different \gls{lcg} have been taken in account. The first one has $a = 18$ and $m = 101$, the implementation is the following and the pairs $(U_i, U_{i+1})$ are plotted in \autoref{fig:es4_a}. In the second case $a = 2$ and $m = 101$ and the same pairs are plotted in \autoref{fig:es4_b}. Both \gls{lcg} are non full-period and a strong correlation is showed in the plots.
\begin{python}
  #LCG1
  a = 18
  x = []
  x.append((a*s+b)%m)
  periodReached = False
  while not periodReached:
  x_new =  (a*x[-1] + b)%m
  if x_new in x:
  periodReached = True
  else:
  x.append(x_new)

  x[:] = [k/m for k in x] #Normalization of x
  print('Period of LCG1 is ' + str(len(x)) + '\n')
  if len(x) < m:
  print('LCG1 is not full period')
  elif len(x) == m:
  print('LCG1 is full period')

  fig = plt.figure(1)
  for i in range(0,len(x)):
  for j in range(0,len(x)):
  plt.plot(x[i],x[j], '.', markersize=2)

  plt.tight_layout()
  plt.savefig('es4_a.pdf')
\end{python}

\begin{figure}[ht]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{es4_a}
		\caption{Pairs $(U_i, U_{i+1})$ of the first \gls{lcg}}
		\label{fig:es4_a}
	\end{minipage}
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{es4_b}
		\caption{Pairs $(U_i, U_{i+1})$ of the second \gls{lcg}}
    \label{fig:es4_b}
	\end{minipage}
\end{figure}

\section{}
In the last exercise, a similar \gls{lcg} has been taken in account. This time the parameters are  $a = 65539$ and $m = 2^{31}$. The result is a non full-period \gls{lcg} where the pairs  $(U_i, U_{i+1})$ seems actually random (see \autoref{fig:es5_a}), but if we see at the tuple  $(U_i, U_{i+1}, U_{i+2})$ in \autoref{fig:es5_b}, a strong correlation is visible in the \gls{lcg}'s realizations. The correspondent code follows the figures.

\begin{figure}[ht]
	\centering
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{es5_a}
		\caption{Pairs $(U_i, U_{i+1})$ of the last \gls{lcg}}
		\label{fig:es5_a}
	\end{minipage}
	\begin{minipage}{0.45\textwidth}
		\centering
		\includegraphics[width=\textwidth]{es5_b}
		\caption{Tuple $(U_i, U_{i+1}, U_{i+2})$ of the last \gls{lcg}}
    \label{fig:es5_b}
	\end{minipage}
\end{figure}

\begin{python}
  m = 2**31
  b = 1
  s = 653
  #LCG
  a = 65539
  x = []
  x.append((a*s+b)%m)
  start = time.time()
  for i in range(0,1200):
    x.append((a*x[-1] + b)%m)

  x[:] = [k/m for k in x] #Normalization of x

  fig = plt.figure(1)
  for i in range(0,len(x) - 1):
    plt.plot(x[i],x[i+1], '.b', markersize=2)

  plt.tight_layout()
  plt.savefig('es5_a.pdf')

  print(range(11,17))

  fig = plt.figure(2)
  ax = fig.add_subplot(111, projection='3d')
  for i in range(0,len(x) - 2):
    ax.scatter(x[i],x[i+1], x[i+2], c='b', marker='.')

  ax.view_init(azim=50)
  # ax.view_init(elev=60)
  plt.tight_layout()
  plt.savefig('es5_b.pdf')
  end = time.time()
  print('Time = '+str(end - start))
\end{python}
\end{document}